//----------------------------------------------------------------------------------------------------------------------------------
//
//							Author: Sonikku
//
//                              ______
//	                      _.-*'"      "`*-._
//	                _.-*'                  `*-._
//	             .-'                            `-.
//	  /`-.    .-'                  _.              `-.
//	 :    `..'                  .-'_ .                `.
//	 |    .'                 .-'_.' \ .                 \
//	 |   /                 .' .*     ;               .-'"
//	 :   L                    `.     | ;          .-'
//	  \.' `*.          .-*"*-.  `.   ; |        .'
//	  /      \        '       `.  `-'  ;      .'
//	 : .'"`.  .       .-*'`*-.  \     .      (_
//	 |              .'        \  .             `*-.
//	 |.     .      /           ;                   `-.
//	 :    db      '       d$b  |                      `-.
//	 .   :PT;.   '       :P"T; :                         `.
//	 :   :bd;   '        :b_d; :                           \
//	 |   :$$; `'         :$$$; |                            \
//	 |    TP              T$P  '                             ;
//	 :                        /.-*'"`.                       |
//	.sdP^T$bs.               /'       \
//	$$$._.$$$$b.--._      _.'   .--.   ;
//	`*$$$$$$P*'     `*--*'     '  / \  :
//	   \                        .'   ; ;
//	    `.                  _.-'    ' /
//	      `*-.                      .'
//	          `*-._            _.-*'
//	               `*=--..--=*'
//
//
//					FILENAME: ir.c
//					Purpose: Infra-red remote control decoder library
//					Dependencies: Interrupt capability on the pin used for receiving the bitstream from the IR receiver
//							      A timer module, clocked to be able to count at a resolution of
//
//
//
//----------------------------------------------------------------------------------------------------------------------------------

// Includes
//---------------

#include "ir.h"
#include "stm32f0xx_rcc.h"			// For STM32F0xx micros
#include <stdio.h>
#include <string.h>
#include "serial.h"

// Definitions, constants etc
//------------------------------------
#define START_PULSE_MIN		7850				// NEC protocol minimum start pulse width
#define START_PULSE_MAX		9500				// NEC protocol maximum start pulse width
#define QUIET_MIN 4280
#define QUIET_MAX 4600

TIM_ICInitTypeDef  TIM_ICInitStructure;				// Input capture registers struct
GPIO_InitTypeDef GPIO_InitStructure;				// GPIO struct
NVIC_InitTypeDef NVIC_InitStructure;				// Interrupt Controller struct

char dbgstr[32];
unsigned char T1;
uint32_t CAPTURE;
//-------------------------------------------------------------------------------------------
// Name: InitIR
// Function: Initialises the timer used, and the interrupt for the IR receiver
// Parameters: void
// Returns: void
//------------------------------------------------------------------------------------------
void InitIR(void){

	// Enable clock to TIM1
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);

	// TIM1_CH2 pin is an AF2 on PA9
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	// For debug- Set up PA10 for the oscilloscope
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_ResetBits(GPIOA, GPIO_Pin_10);

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_2);

	// Enable interrupt TIM1
	NVIC_InitStructure.NVIC_IRQChannel = TIM1_CC_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);


	// Input Capture setup...
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
	TIM_ICInitStructure.TIM_ICFilter = 0x0;
	TIM_ICInit(TIM1, &TIM_ICInitStructure);

	// Enable the TIM1
	TIM_PrescalerConfig(TIM1, 48, TIM_PSCReloadMode_Immediate);
	TIM_Cmd(TIM1, ENABLE);
	TIM_ITConfig(TIM1, TIM_IT_CC2, ENABLE);
	T1 = 0;

}


//-----------------------------------------------------------------------------------------
// Name: ChangeEdge
// Function: Changes the detection edge of the CC under program control
// Parameters: 0 = falling, 1 = rising
// Returns: void
//-----------------------------------------------------------------------------------------
void ChangeEdge(unsigned char edge){

	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
	if (edge == 1){
		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
	}

	if (edge == 0){
		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;

	}
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
	TIM_ICInitStructure.TIM_ICFilter = 0x0;
	TIM_ICInit(TIM1, &TIM_ICInitStructure);

	TIM_ClearITPendingBit(TIM1, TIM_IT_CC2);						// Clear possible IRQ raised from edge change

}

//-----------------------------------------------------------------------------------------
// Name: ResetIR
// Function: Reset the IR logic
//-----------------------------------------------------------------------------------------
void ResetIR(void){

	T1 = 0;
	ChangeEdge(0);

}
//-----------------------------------------------------------------------------------------
// Name: IR_IRQ_HNDL
// Interrupt Handler for input pulses (falling edge)
//----------------------------------------------------------------------------------------
void IR_IRQ_HNDL(void){

    TIM_ClearITPendingBit(TIM1, TIM_IT_CC2);		// Clear IRQ
    memset(dbgstr, 0, 32);
    CAPTURE = TIM_GetCapture2(TIM1);				// Grab the captured value
    switch(T1){

    // Initial state - captured first edge of the incoming stream
    case 0:
    	GPIO_SetBits(GPIOA, GPIO_Pin_10);
    	TIM_SetCounter(TIM1, 0);
    	ChangeEdge(1);													// Change edge to rising
    	T1 = 1;
    	break;

    // End of start pulse, begin of quiet time
    case 1:
    	GPIO_ResetBits(GPIOA, GPIO_Pin_10);
    	ChangeEdge(0);												   // Next edge will always be falling
    	if (CAPTURE > START_PULSE_MIN && CAPTURE < START_PULSE_MAX){
    		T1 = 2;		// Valid start pulse, go next
    		TIM_SetCounter(TIM1, 0);
    	} else {
    		T1 = 0;		// Invalid start pulse, start over
    	}
    	break;

    // End of quiet time, begin of first data bit
    case 2:
    	GPIO_SetBits(GPIOA, GPIO_Pin_10);
    	ChangeEdge(1);
    	if (CAPTURE > QUIET_MIN && CAPTURE < QUIET_MAX){
    		T1 = 3;
    		TIM_SetCounter(TIM1, 0);
    	}
    	break;

    case 3:
    	//sprintf(dbgstr, "\r\n Rising Edge of (START): %u", TIM_GetCapture2(TIM1));
    	TxData("\r\nValid IR packet start detected!");
    	T1 = 4;
    	break;

    default:
    	break;


    }


}
