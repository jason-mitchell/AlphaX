//----------------------------------------------------------------------------------------------------------------------------------
//
//							Author: Sonikku
//
//                              ______
//	                      _.-*'"      "`*-._
//	                _.-*'                  `*-._
//	             .-'                            `-.
//	  /`-.    .-'                  _.              `-.
//	 :    `..'                  .-'_ .                `.
//	 |    .'                 .-'_.' \ .                 \
//	 |   /                 .' .*     ;               .-'"
//	 :   L                    `.     | ;          .-'
//	  \.' `*.          .-*"*-.  `.   ; |        .'
//	  /      \        '       `.  `-'  ;      .'
//	 : .'"`.  .       .-*'`*-.  \     .      (_
//	 |              .'        \  .             `*-.
//	 |.     .      /           ;                   `-.
//	 :    db      '       d$b  |                      `-.
//	 .   :PT;.   '       :P"T; :                         `.
//	 :   :bd;   '        :b_d; :                           \
//	 |   :$$; `'         :$$$; |                            \
//	 |    TP              T$P  '                             ;
//	 :                        /.-*'"`.                       |
//	.sdP^T$bs.               /'       \
//	$$$._.$$$$b.--._      _.'   .--.   ;
//	`*$$$$$$P*'     `*--*'     '  / \  :
//	   \                        .'   ; ;
//	    `.                  _.-'    ' /
//	      `*-.                      .'
//	          `*-._            _.-*'
//	               `*=--..--=*'
//
//
//					FILENAME: ir.c
//					Purpose: Infra-red remote control decoder library
//					Dependencies: Interrupt capability on the pin used for receiving the bitstream from the IR receiver
//							      A timer module, clocked to be able to count at a resolution of
//
//
//
//----------------------------------------------------------------------------------------------------------------------------------

// Includes
//---------------

#include "ir.h"
#include "stm32f0xx_rcc.h"			// For STM32F0xx micros
#include <stdio.h>
#include <string.h>
#include "serial.h"

// Definitions, constants etc
//------------------------------------
#define START_PULSE_MIN		7850				// NEC protocol minimum start pulse width
#define START_PULSE_MAX		9500				// NEC protocol maximum start pulse width
#define QUIET_MIN 3800
#define QUIET_MAX 4700

#define BIT_A_MIN 504
#define BIT_A_MAX 578
#define BIT_B_MIN 380
#define BIT_B_ZERO 602
#define BIT_B_ONE 801

TIM_ICInitTypeDef  TIM_ICInitStructure;				// Input capture registers struct
GPIO_InitTypeDef GPIO_InitStructure;				// GPIO struct
NVIC_InitTypeDef NVIC_InitStructure;				// Interrupt Controller struct

char dbgstr[32];
unsigned char T1;
unsigned char data_toggle;
unsigned char bitcount;
uint32_t CAPTURE;
uint32_t IR_DATA;
//-------------------------------------------------------------------------------------------
// Name: InitIR
// Function: Initialises the timer used, and the interrupt for the IR receiver
// Parameters: void
// Returns: void
//------------------------------------------------------------------------------------------
void InitIR(void){

	// Enable clock to TIM1
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);

	// TIM1_CH2 pin is an AF2 on PA9
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	// For debug- Set up PA10 for the oscilloscope
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_ResetBits(GPIOA, GPIO_Pin_10);

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_2);

	// Enable interrupt TIM1
	NVIC_InitStructure.NVIC_IRQChannel = TIM1_CC_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);


	// Input Capture setup...
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_BothEdge;
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
	TIM_ICInitStructure.TIM_ICFilter = 0x0;
	TIM_ICInit(TIM1, &TIM_ICInitStructure);

	// Enable the TIM1
	TIM_PrescalerConfig(TIM1, 48, TIM_PSCReloadMode_Immediate);
	TIM_Cmd(TIM1, ENABLE);
	TIM_ITConfig(TIM1, TIM_IT_CC2, ENABLE);
	T1 = 0;

}


//-----------------------------------------------------------------------------------------
// Name: ResetIR
// Function: Reset the IR logic
//-----------------------------------------------------------------------------------------
void ResetIR(void){
	T1 = 0;
	data_toggle = 0;
	IR_DATA = 0;
}
//-----------------------------------------------------------------------------------------
// Name: IR_IRQ_HNDL
// Interrupt Handler for input pulses (falling edge)
//----------------------------------------------------------------------------------------
void IR_IRQ_HNDL(void){

    TIM_ClearITPendingBit(TIM1, TIM_IT_CC2);		// Clear IRQ
    CAPTURE = TIM_GetCapture2(TIM1);				// Grab the captured value
    TIM_SetCounter(TIM1, 0);						// Clear the timer

    switch(T1){

    // Initial state - captured first edge of the incoming stream
    case 0:
    	CAPTURE = 0;											// Reset CAPTURE value
    	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == 0){
    		T1 = 1;												// Falling edge we can go to the next state
    	}
    	break;

    // Start pulse is measured
    case 1:
    	if (CAPTURE > START_PULSE_MIN && CAPTURE < START_PULSE_MAX){
    		T1 = 2;
    	} else {
    		GPIO_ResetBits(GPIOA, GPIO_Pin_10);
    		T1 = 0;
    		data_toggle = 0;
    	}
    	break;

    // Space pulse is measured
    case 2:
    	if (CAPTURE > QUIET_MIN && CAPTURE < QUIET_MAX){
    		bitcount = 8;
    		T1 = 3;

    	} else {
    		GPIO_ResetBits(GPIOA, GPIO_Pin_10);
    		T1 = 0;
    		data_toggle = 0;
    	}
    	break;

    // Incoming datastream
    case 3:
    	if (data_toggle == 0){
    		// First part of bit encoding
    		if(CAPTURE > BIT_A_MIN && CAPTURE < BIT_A_MAX){
    			data_toggle = 1;								// First part is good!
    			break;
    		}

    	} else {
    		// Second part of bit encoding
    		if (CAPTURE > BIT_B_MIN){
    			data_toggle = 0;
    			if (CAPTURE > BIT_B_ONE){
    				IR_DATA = IR_DATA >> 1;
    				IR_DATA |= 0x80000000;
    				//GPIO_SetBits(GPIOA, GPIO_Pin_10);
    			} else {
    				//GPIO_ResetBits(GPIOA, GPIO_Pin_10);
    				IR_DATA = IR_DATA >> 1;
    				IR_DATA &= ~0x80000000;
    			}
    		}

    		bitcount--;
    		if (bitcount == 0){
    			T1 = 4;
    			dbgstr[0] = 0;
    			sprintf(dbgstr, "Decoded IR data = 0x%08X\r\n", IR_DATA);
    			TxData(dbgstr);
    			break;
    		}

    		break;
    	}

    	break;


    default:
    	break;


    }


}
