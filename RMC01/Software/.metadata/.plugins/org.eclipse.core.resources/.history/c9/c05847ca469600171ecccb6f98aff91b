//
//
//
//
//
//
//-----------------------------------------------------------------------------------------------------------------------------------------



// Includes
//--------------------------------------------------------
#include <msp430g2231.h>


// Definitions
//-------------------------------------------------------
#define ROW1	BIT3
#define ROW2	BIT4

#define	COL1	BIT5
#define COL2	BIT6
#define COL3	BIT7

unsigned int IR_TIME = 0;
unsigned char TRANSMIT_REQ = 0;
unsigned char keycode;



// Local Functions
//------------------

// Name: PulseTimer
// Function: Generates accurate pulse times
// Parameters: Time period desired in uSeconds
// Returns: void
//-----------------------------------------------------
void PulseTimer(unsigned int time){
	unsigned int TCOMP;


	IR_TIME = 0;					// Reset timing register
	WDTCTL = WDT_MDLY_0_064; 		// Enable WDT with a period of 64uS

	TCOMP = (time / 64) - 2;
	for(;;){
		if(IR_TIME >= TCOMP){
			WDTCTL = WDTPW + WDTHOLD;					// Disable WDT
			break;
		}
	}
}



//=======================================
void Wait(unsigned int delay){
	unsigned int ttr = 0;
	for (ttr = 0; ttr < delay; ttr++){
		__delay_cycles(1000);
	}

}

//----------------------------------------------------------------------------------------------------
// Name: PWMPinControl
// Function: Controls the drive of the PWM pin
//           This means when the CPU is halted we don't end up with the pin sitting at logic 1
//----------------------------------------------------------------------------------------------------
void PWMPinControl(unsigned char CTL){
	if(CTL == 0){
		P1DIR &= ~BIT2;		// PWM pin
		P1OUT &= ~BIT0;		// Debug pin
	} else {
		P1DIR |= BIT2;		// PWM pin
		P1OUT |= BIT0;		// Debug pin
	}

}

// Name: TransmitBit
// Function: Generate the symbol pattern for a logic 0 or 1
//----------------------------------------------------------------
void TransmitBit(unsigned char bit){
	PWMPinControl(1);				// enable 38kHz IR modulation
	PulseTimer(562);				// 562uS pulse
	PWMPinControl(0);
	if(bit == 0){
		PulseTimer(562);
	} else {
		PulseTimer(1675);
	}
}


//----------------------------------------------------------------
// Name: ScanKeys
// Function: Scan keyboard
// Parameters: void
// Returns: scanned key
//---------------------------------------------------------------
unsigned char ScanKeys(void){

	// Columns scanned sequentially

	// Column 1
	P1OUT |= COL1;
	switch(P1IN & 0x18){
	case 0x08:
		return 0x01;
		break;

	case 0x10:
		return 0x02;
		break;
	}

	P1OUT &= ~COL1;
	Wait(10);

	// Column 2
	P1OUT |= COL2;
	switch(P1IN & 0x18){
	case 0x08:
		return 0x03;
		break;

	case 0x10:
		return 0x04;
		break;
	}

	P1OUT &= ~COL2;
	Wait(10);

	// Column 3
	P1OUT |= COL3;
	switch(P1IN & 0x18){
	case 0x08:
		return 0x05;
		break;

	case 0x10:
		return 0x06;
		break;
	}

	P1OUT &= ~COL3;
	Wait(10);
	return 0x00;
}

//----------------------------------------------------------------
// Name: TransmitNEC
// Function: Generates a complete NEC IR protocol frame
// Parameters: Address field, Command field
// Returns: void
//----------------------------------------------------------------
void TransmitNEC(unsigned int address, unsigned int command){

	unsigned char bitcount;

	// First, generate the start-of-frame
	PWMPinControl(1);								// Start 38kHz modulation
	PulseTimer(8400);								// 9mS leading pulse
	PWMPinControl(0);								// Stop 38kHz modulation
	PulseTimer(4090);								// 4.5mS gap

	// Transmit address LSB first
	for(bitcount = 0; bitcount < 16; bitcount++){
		if ((address & 0x0001) == 0x01){
			TransmitBit(1);
		} else {
			TransmitBit(0);
		}
		address = address >> 1;
	}

	// Transmit command LSB first
	for(bitcount = 0; bitcount < 16; bitcount++){
		if ((command & 0x0001) == 0x01){
			TransmitBit(1);
		} else {
			TransmitBit(0);
		}
		command = command >> 1;
	}

	TransmitBit(0);			// This is required... not sure why but it doesn't work if deleted
}
//--------------------------------------------------------------------------------------
// 										Main Function
//--------------------------------------------------------------------------------------
void main(void) {

	   WDTCTL = WDTPW + WDTHOLD;					// Disable WDT
	   IE1 |= WDTIE; // Enable WDT interrupt
	   TRANSMIT_REQ = 0;							// Clear flag
	   DCOCTL = 0;                               	// Select lowest DCOx and MODx settings
	   BCSCTL1 = CALBC1_1MHZ;                    	// Set range
	   DCOCTL = CALDCO_1MHZ;                     	// Set DCO step + modulation */
	   BCSCTL2 = 0x00;								// SMCLK /4 (done here to reduce the clock jitter problem)

	   // Configure I/O pins
	   P1DIR |= BIT0;								// P1.0 to output (DEBUG purposes)
	   P1DIR |= BIT2;             					// P1.2 to output
	   P1SEL |= BIT2;             					// P1.2 to TA0.1
	   P1OUT &= ~BIT0;								// Set debug pin to low

	   P1DIR |= COL1;
	   P1DIR |= COL2;
	   P1DIR |= COL3;

	   P1OUT |= COL1;								// All three column lines high (same technique as per uPD1986 and others)
	   P1OUT |= COL2;
	   P1OUT |= COL3;

	   // Configure Timer 1 (TA0.0)
	   //---------------------------------
	   TACTL = TACLR;								// Clear Timer

	   // Configure Capture/Compare to output a 38kHz clock
	   // Closest we can get is 39.07kHz

	   CCR0 = 25-1;             				// PWM Period       50 = 20kHz
	   CCTL1 = OUTMOD_7;          				// CCR1 reset/set
	   CCR1 = 12;                				// CCR1 PWM duty cycle 50% is given if this value = CCR0 / 2
	   TACTL = TASSEL_2 + MC_1;   				// SMCLK, up mode, timer running


		P1IE |= BIT3; 							// enable P1.3 interrupt
		P1IE |= BIT4;							// enable P1.4 interrupt
		__enable_interrupt();					// Enable System interrupts
		PWMPinControl(0);						// PWM pin disabled
		_BIS_SR(LPM3_bits + GIE); 				// Enter LPM3 w/interrupt


	//------------------------------------------------------
	// Main Handling Loop
	//-----------------------------------------------------
	for(;;) {

		// Decode the keyboard by scanning it
		if((P1IN & 0x18) == 0x08 || (P1IN & 0x18) == 0x10){
			P1OUT &= ~COL1;
			P1OUT &= ~COL2;
			P1OUT &= ~COL3;							// All three to zero
			Wait(10);									// Delay for capacitance

			keycode = ScanKeys();
			switch(keycode){
			case 0x01:
				TransmitNEC(0xC7F8, 0x0738);
				break;

			case 0x02:
				TransmitNEC(0xC7F8, 0x0739);
				break;

			}

			// Transmission complete
			P1OUT |= COL1;								// All three column lines high (same technique as per uPD1986 and others)
			P1OUT |= COL2;
			P1OUT |= COL3;
			TRANSMIT_REQ = 0;
			Wait(100);
			_BIS_SR(LPM3_bits + GIE); 				// Enter LPM3 w/interrupt


//		if((P1IN & 0x08) == 0x08){ */
//			TransmitNEC(0xC7F8, 0x0738);

			P1OUT |= COL1;								// All three column lines high
			P1OUT |= COL2;
			P1OUT |= COL3;
			Wait(100);
			TRANSMIT_REQ = 0;
			_BIS_SR(LPM3_bits + GIE); 				// Enter LPM3 w/interrupt

		}
	}
}

// Watchdog Timer interrupt service routine
// Used here as a timer
//-----------------------------------------
#pragma vector=WDT_VECTOR
__interrupt void watchdog_timer(void){
	IR_TIME++;

}

// Port 1 interrupt service routine - executed when buttons are pressed
//-----------------------------------------------------------------------
#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void){
	P1IFG = 0x0;
	if(TRANSMIT_REQ == 0){
		TRANSMIT_REQ = 1;
		_BIC_SR(LPM3_EXIT); // wake up from low power mode
	}

}

